# Архитектура ПО

## Урок 1. Введение в понятие архитектуры, проектирование ПО и жизненный цикл программного продукта. UML-диаграммы

### Задание 1. На основе Диаграмы классов ModelElements, разработать классы: Model Store, PoligonalModel (Texture, Poligon), Flash, Camera, Scene (Реализовать диограмму на любом языке программирования)

### Задание 2. Ознакомиться с документацией в свободном формате, которая может пригодиться Вам для дальнейшей работы:

ГОСТ Р ИСО/МЭК 12207-2010 Информационная технология (ИТ). Системная и программная инженерия. Процессы жизненного цикла программных средств.
ISO/IEC/IEEE 29148:2018 Systems and software engineering — Life cycle processes — Requirements engineering
Стандарты ЕСКД — единая система конструкторской документации
ГОСТ 2.001-2013 ЕСКД. Общие положения
Стандарты АСУ ГОСТ 34 — автоматизированные системы управления
Стандарты ЕСПД ГОСТ 19 — единая система программной документации

https://www.cybermedian.com/ru/a-comprehensive-guide-to-uml-class-diagram/

В этой призентации, в конце есть диограмма для Задания 1:

https://docs.google.com/presentation/d/1d-ReTu3A_944hmccTxqbUrRNMHtIDViiCMKvUUaKu24/edit?pli=1#slide=id.g161fe117232_1_7

### Задание 3. (На выбор 1 или 3 задание )
Создать UML Диограмму Классов.

**Задание: Разработка системы для онлайн-магазина книг.**
Описание:
Вы разрабатываете диаграмму классов для онлайн-магазина книг. Система позволяет пользователям просматривать каталог книг, оформлять заказы и получать информацию о заказанных книгах.

**Требования:**
Создайте классы для представления книг, пользователей и заказов.

Класс "Книга" должен содержать атрибуты, такие как название, автор, жанр и цена.

Примеры атрибутов:

> title: String (название книги)
> author: String (автор книги)
> genre: String (жанр книги)
> price: double (цена книги)

Класс "Пользователь" должен содержать атрибуты, такие как имя, адрес электронной почты и список заказанных книг.

Примеры атрибутов:

> name: String (имя пользователя)
> email: String (адрес электронной почты пользователя)
> orderedBooks: List<Book> (список заказанных книг)

Класс "Заказ" должен содержать атрибуты, такие как идентификатор заказа, дата оформления заказа и список книг, включенных в заказ.

Примеры атрибутов:

> orderId: int (идентификатор заказа)
> orderDate: Date (дата оформления заказа)
> orderedBooks: List<Book> (список книг в заказе)

Предоставьте методы в соответствующих классах для получения и установки значений атрибутов.

Примеры методов:

> public String getTitle(): возвращает название книги.
> public void setTitle(String title): устанавливает название книги.
> public List<Book> getOrderedBooks(): возвращает список заказанных книг пользователя.
> public void addBookToOrder(Book book): добавляет книгу в список заказанных книг.

Добавьте методы в класс "Пользователь" для добавления книг в список заказов и получения общей стоимости заказа.

Примеры методов:

> public double getTotalOrderCost(): возвращает общую стоимость заказа пользователя.

Добавьте метод в класс "Заказ" для получения информации о заказанных книгах и общей стоимости заказа.

Примеры методов:

> public List<Book> getOrderedBooks(): возвращает список книг в заказе.
> public double getTotalOrderCost(): возвращает общую стоимость заказа.

Предоставьте ассоциации между классами "Книга" и "Пользователь", а также между классами "Пользователь" и "Заказ".

Примеры ассоциаций:

> "Пользователь" ассоциирован с "Книгой" через атрибут "orderedBooks" (отношение "1..").
> "Пользователь" ассоциирован с "Заказом" через атрибут "orderedBooks" (отношение "1..").

Добавьте несколько методов в класс "Книга" и "Пользователь", чтобы сделать систему более интересной.

Примеры дополнительных методов:

> public void addToFavorites(Book book): добавляет книгу в избранное пользователя.
> public List<Order> getOrderHistory(): возвращает историю заказов пользователя.

Помните о правильных связях между классами, таких как агрегация или ассоциация.

**Ниже помощь для 3-го задания:**

Декомпозиция задачи на разработку диаграммы классов для онлайн-магазина книг:
Определение основных классов и их атрибутов:

Класс "Книга" с атрибутами: название, автор, жанр, цена.
Класс "Пользователь" с атрибутами: имя, адрес электронной почты, список заказанных книг.
Класс "Заказ" с атрибутами: идентификатор заказа, дата оформления заказа, список книг в заказе.
Определение связей между классами:

Класс "Пользователь" ассоциирован с классом "Книга" через атрибут "orderedBooks" (отношение "1..").
Класс "Пользователь" ассоциирован с классом "Заказ" через атрибут "orderedBooks" (отношение "1..").
Добавление методов в класс "Книга":

getTitle(): возвращает название книги.
setTitle(String title): устанавливает название книги.
getAuthor(): возвращает автора книги.
setAuthor(String author): устанавливает автора книги.
getGenre(): возвращает жанр книги.
setGenre(String genre): устанавливает жанр книги.
getPrice(): возвращает цену книги.
setPrice(double price): устанавливает цену книги.
Добавление методов в класс "Пользователь":

getName(): возвращает имя пользователя.
setName(String name): устанавливает имя пользователя.
getEmail(): возвращает адрес электронной почты пользователя.
setEmail(String email): устанавливает адрес электронной почты пользователя.
getOrderedBooks(): возвращает список заказанных книг пользователя.
addBookToOrder(Book book): добавляет книгу в список заказанных книг.
Добавление методов в класс "Заказ":

getOrderId(): возвращает идентификатор заказа.
setOrderId(int orderId): устанавливает идентификатор заказа.
getOrderDate(): возвращает дату оформления заказа.
setOrderDate(Date orderDate): устанавливает дату оформления заказа.
getOrderedBooks(): возвращает список книг в заказе.
addBookToOrder(Book book): добавляет книгу в список книг в заказе.
Добавление дополнительных методов (опционально):

addToFavorites(Book book): добавляет книгу в избранное пользователя.
getTotalOrderCost(): возвращает общую стоимость заказа пользователя.
getOrderHistory(): возвращает историю заказов пользователя.

## Урок 2. Объектно-ориентированные паттерны ##

Код с семинара на Java: https://github.com/vyntyk/FabricMethod.git

Код с семинара на Python: https://github.com/JuliaRyzhova/Software_architecture/tree/main/Seminar_2

**Задание**

Прислать простую реализацию 5-ти Патернов, на любом языке, из списка:

Строитель (Builder)
Цепочка обязанностей (Chain of Responsibility)
Команда (Command)
Итератор (Iterator)
Посредник (Mediator)
Памятка (Memento)
Состояние (State)
Стратегия (Strategy)
Шаблонный метод (Template Method)
Посетитель (Visitor)

Познакомиться с другими типами паттернов(по желанию)

## Урок 3. Принципы SOLID ##

https://github.com/vyntyk/Solid.git

Продолжить работу с семинара.
рассмотрим четвертый принцип SOLID - Принцип сегрегации интерфейса (Interface Segregation Principle, ISP). Он гласит: "Клиенты не должны зависеть от интерфейсов, которые они не используют".
Вам надо написать код который исправяет эту ошибку и реализует этот принцип
Пример кода, который нарушает ISP:

> public interface Worker {
> void work();
> void eat();
> }

> public class HumanWorker implements Worker {
> public void work() {
> System.out.println("Человек работает");
> }

> public void eat() {
>    System.out.println("Человек ест");
>}
>}

> public class RobotWorker implements Worker {
> public void work() {
> System.out.println("Робот работает");
> }

> public void eat() {
>    throw new UnsupportedOperationException("Роботы не едят!");
> }
> }

> public class Main {
> public static void main(String[] args) {
> Worker worker = new RobotWorker();
> worker.work();
> worker.eat(); // Здесь возникнет исключение UnsupportedOperationException
> }
> }
 
В этом примере класс RobotWorker не использует и не должен использовать метод eat(), поэтому он нарушает принцип сегрегации интерфейса.

И аналогично 5-ый принцип

Принцип инверсии зависимостей (Dependency Inversion Principle, DIP) гласит: "Зависимости на абстракциях. Нет зависимостей на что-то конкретное". Это означает, что высокоуровневые модули, которые обеспечивают сложную логику, должны быть независимы от низкоуровневых модулей, которые обеспечивают утилитарные функции. Оба типа модулей должны зависеть от абстракций.

Пример кода, который нарушает DIP:

> public class Text {
>     String text;
>
>     public Text(String text) {
>         this.text = text;
>     }
>
>     public String getText() {
>         return text;
>     }
> }
> 
> public class Printer {
>     public void print(Text text) {
>         System.out.println(text.getText());
>     }
> }
> 
> public class Main {
>     public static void main(String[] args) {
>         Text myText = new Text("Hello, world!");
>         Printer myPrinter = new Printer();
>         myPrinter.print(myText);
>     }
> }

В этом примере класс Printer зависит от конкретного класса Text.

## Урок 4. Компоненты. Принципы связности и сочетаемости компонентов ##

Вам необходимо доработать код, добавив контракты к методам, документацию и обеспечив высокую связанность и низкую сочетаемость:

> // Класс для геометрических фигур
> abstract class Shape {
>     // Общие поля и методы для всех геометрических фигур
>     abstract double getArea();
>     abstract double getPerimeter();
> }
> 
> // Класс для круга
> class Circle extends Shape {
>     private double radius;
> 
>     public Circle(double radius) {
>         this.radius = radius;
>     }
> 
>     @Override
>     double getArea() {
>         return Math.PI * radius * radius;
>     }
> 
>     @Override
>     double getPerimeter() {
>         return 2 * Math.PI * radius;
>     }
> }
> 
> // Класс для прямоугольника
> class Rectangle extends Shape {
>     private double length;
>     private double width;
> 
>     public Rectangle(double length, double width) {
>         this.length = length;
>         this.width = width;
>     }
> 
>     @Override
>     double getArea() {
>         return length * width;
>     }
> 
>     @Override
>     double getPerimeter() {
>         return 2 * (length + width);
>     }
> }
> 
> // Класс для треугольника
> class Triangle extends Shape {
>     private double side1;
>     private double side2;
>     private double side3;
> 
>     public Triangle(double side1, double side2, double side3) {
>         this.side1 = side1;
>         this.side2 = side2;
>         this.side3 = side3;
>     }
> 
>     @Override
>     double getArea() {
>         double s = (side1 + side2 + side3) / 2;
>         return Math.sqrt(s * (s - side1) * (s - side2) * (s - side3));
>     }
> 
>     @Override
>     double getPerimeter() {
>         return side1 + side2 + side3;
>     }
> }
> 
> // Главный класс приложения
> public class GeometryApp {
>     public static void main(String[] args) {
>         // Пример использования конкретных классов геометрических фигур
>         Circle circle = new Circle(5.0);
>         System.out.println("Площадь круга: " + circle.getArea());
>         System.out.println("Периметр круга: " + circle.getPerimeter());
> 
>         Rectangle rectangle = new Rectangle(4.0, 6.0);
>         System.out.println("Площадь прямоугольника: " + rectangle.getArea());
>         System.out.println("Периметр прямоугольника: " + rectangle.getPerimeter());
> 
>         Triangle triangle = new Triangle(3.0, 4.0, 5.0);
>        System.out.println("Площадь треугольника: " + triangle.getArea());
>         System.out.println("Периметр треугольника: " + triangle.getPerimeter());
>     }
> }

## Урок 5. Горизонтальные уровни и вертикальные срезы архитектуры ##

Джава: https://github.com/vyntyk/Srezy.git
Питон: https://github.com/JuliaRyzhova/Software_architecture/tree/main/Seminar_5

Реализовать любой паттерн с лекции . Выпустить диаграмму компонент UML по нему.

## Урок 6. Принципы построения приложений «чистая архитектура» ##

**Задание: Переделка программы под чистую архитектуру**

Вам предоставляется программа, которая представляет интернет-магазин книг с использованием коллекций. Ваша задача - переработать эту программу, применяя принципы чистой архитектуры для лучшей организации кода и разделения компонентов. В результате переработки программа должна следовать принципам Boundary-Control-Entity (BCE).

**Требования:**

- Создайте пакеты domain, data, и presentation.
- В пакете domain создайте классы, представляющие бизнес-объекты интернет-магазина книг. Например, Book - представляющий модель книги.
- В пакете data создайте интерфейс BookRepository, определяющий методы для управления книгами в интернет-магазине. Затем реализуйте этот интерфейс в классе InMemoryBookRepository, используя коллекции для хранения данных о книгах.
- В пакете presentation создайте класс Main, который будет представлять точку входа в приложение и обрабатывать пользовательские запросы.
- Используйте принципы чистой архитектуры для организации компонентов (BCE). Каждый компонент должен быть отделен от других, взаимодействие должно происходить через абстракции, а не через конкретные реализации.
- Перенесите функциональность работы с коллекциями и хранения данных в пакет data, таким образом, чтобы она не проникала в другие компоненты.
- Обеспечьте возможность добавления, удаления и получения списка книг через интерфейс BookRepository, а затем используйте его в Main для управления книгами.
- Убедитесь, что код программы чистый, читаемый и хорошо структурированный. Обеспечьте надлежащее разделение ответственности между компонентами и минимизируйте повторяющийся код.

**Примечание:**
Данный код предоставлен только для ознакомления с исходной реализацией и не представляет полный функционал интернет-магазина книг. Ваша задача - переработать его согласно принципам чистой архитектуры и обеспечить соответствующий функционал.

Вот пример кода, представляющего интернет-магазин книг с использованием коллекций, но без реализации чистой архитектуры:

> import java.util.ArrayList;
> import java.util.List;
> 
> // Класс представляющий книгу
> 
> class Book {
>     private String id;
>     private String title;
>     private String author;
>     private double price;
> 
>     // Конструктор, геттеры и сеттеры
> }
> 
> // Класс, реализующий хранилище книг с использованием коллекций
> 
> class BookStore {
>     private List<Book> books;
> 
>     public BookStore() {
>         books = new ArrayList<>();
>     }
> 
>     public void addBook(Book book) {
>         books.add(book);
>     }
> 
>     public void removeBook(Book book) {
>         books.remove(book);
>     }
> 
>     public List<Book> getAllBooks() {
>         return books;
>     }
> }
> 
> public class Main {
>     public static void main(String[] args) {
>         BookStore bookStore = new BookStore();
> 
>         // Добавляем книги в магазин
> 
>         Book book1 = new Book("1", "Clean Code", "Robert C. Martin", 34.99);
>         Book book2 = new Book("2", "Effective Java", "Joshua Bloch", 29.99);
>         bookStore.addBook(book1);
>         bookStore.addBook(book2);
> 
>         // Получаем список всех книг в магазине
> 
>         List<Book> allBooks = bookStore.getAllBooks();
>         for (Book book : allBooks) {
>             System.out.println("Книга: " + book.getTitle() + ", Автор: " + book.getAuthor() + ", Цена: $" + book.getPrice());
>         }
>     }
> }

## Урок 7. Типа архитектур WEB-приложений: MPA, SPA. ##

Семинара на эту тему не будет! Изучаем методичку , презентацию , смотрим лекцию.
Берем из материалов самое важное:
- архитектуру браузера;
- структуру web-приложения;
- SPA, CSR, SSR.

**Домашнее задание:**

1. Подготовительный этап:
- Определение целей и задач приложения.
- Анализ аудитории и исследование рынка.
- Создание общего описания концепции и функциональности.

ПРИМЕР ВЫПОЛНЕНИЯ: https://github.com/CrazyQWERTYlunch/software_architecture/tree/main/Homework7

1 - Описать этот этап по примеру ниже , выбрать любую тему для веб приложение.
2 - Пункт 1.7 - необходимо сделать сырой пример страницы , прислать скриншот любой страницы (https://www.figma.com или воспользоваться другим инструментом ), то есть физичекси указать примерные цвета , расположение кнопок и т д. . можно взять за основу мобильную версию , т к ее проще делать . ( Вы не дизайнеры , но дизайнер дорден понять Вашу мысль, чтобы сдедать красило по шаблону )

Вот подробный пример первого пункта подготовительного этапа для интернет-магазина сладостей:

1. Подготовительный этап:

1.1 Определение целей и задач приложения:
- Основная цель: Создать интернет-магазин, предоставляющий покупателям широкий выбор сладостей.
- Задачи:
- Разработать удобный каталог товаров с фотографиями, описаниями и ценами.
- Реализовать систему корзины для добавления товаров и оформления заказа.
- Создать систему авторизации и регистрации пользователей.

1.2 Анализ аудитории и исследование рынка:
- Целевая аудитория: Люди всех возрастов, интересующиеся кондитерскими изделиями и сладостями.
- Исследование рынка: Проанализированы другие интернет-магазины сладостей, определены их особенности и недостатки.

1.3 Создание общего описания концепции и функциональности:
- Концепция: Онлайн-магазин для покупки разнообразных сладостей, от конфет и шоколадок до тортов и печенья.
- Основные функции:
- Просмотр каталога сладостей с фотографиями и описаниями.
- Добавление товаров в корзину и изменение их количества.
- Оформление заказа с выбором способа доставки и оплаты.
- Система авторизации и возможность просмотра истории заказов.

1.4 Выбор бизнес-модели:
- Модель монетизации: Продажа товаров со встроенной наценкой, а также возможность проведения акций и предложений.

1.5 Оценка ресурсов и бюджета:
- Ресурсы: Доступен бюджет для найма разработчиков, дизайнеров и рекламных кампаний.
- Бюджет: Оценка расходов на разработку, дизайн, маркетинг и обслуживание приложения.

1.6 Планирование времени:
- Временной график:
- Определение требований и разработка концепции: 2 недели.
- Проектирование интерфейса и прототипирование: 3 недели.
- Разработка фронтенда и бэкенда: 8 недель.
- Тестирование и доработка: 2 недели.
- Деплой и подготовка к запуску: 1 неделя.

1.7 Проектирование прототипа:
- Создание прототипа интерфейса с основными элементами:
- Главная страница с поиском и категориями сладостей.
- Страница товара с фотографией, описанием и кнопкой "Добавить в корзину".
- Страница корзины с перечнем товаров и возможностью оформления заказа.
- Страница авторизации и регистрации.

Этот пример демонстрирует, как можно применить этап подготовки к конкретному проекту - интернет-магазину сладостей.

## Урок 8. Типы архитектур прикладных приложений (мобильные): MVC, MVP, MVVM. ##

Задание: Создание UML диаграммы классов для веб-приложения

**Пример:** Вы работаете над проектированием веб-приложения для онлайн-магазина книг. Вам нужно создать UML-диаграмму классов, отображающую связи между основными классами вашего приложения. Вам также необходимо создать USE Case диаграмму.

**Инструкции:**

- Определите основные классы, которые будут присутствовать в вашем веб-приложении. Например, классы "Пользователь", "Книга", "Корзина", "Заказ" и другие.
- Определите связи между этими классами. Например, класс "Пользователь" может иметь ассоциацию с классом "Корзина", а класс "Корзина" может иметь ассоциацию с классом "Книга".
- Создайте UML-диаграмму классов, на которой отобразите классы и связи между ними. Не включайте методы и поля, только связи между классами.
- Создайте USE Case диаграмму, покажите связь между пользователем и приложением и другие связи

**Примечание:**

Ваша UML-диаграмма должна визуализировать связи между классами, такие как ассоциации, агрегации и композиции.
Ваша USE Case диаграмма показывает связь между сущностями
Вы можете использовать любой инструмент для создания диаграмм, такой как draw.io, Lucidchart или даже бумагу и карандаш.

## Урок 9. Способы организации передачи данных между компонентами приложения, протоколы и API. REST, gRPC, очереди ##

Материaл с Семинара: https://github.com/vyntyk/untitledAPI.git

**Итоги и ключевые моменты:**

HTTP и REST:

- HTTP - протокол передачи данных в сети, используется для взаимодействия между клиентом и сервером.
- REST (Representational State Transfer) - архитектурный стиль, который определяет принципы для построения веб-сервисов.
- REST API - интерфейс для взаимодействия между клиентами и серверами по принципам REST.
- JSON (JavaScript Object Notation):

*JSON* - легкий формат обмена данными, основанный на синтаксисе JavaScript.
JSON представляет данные в виде пар "ключ-значение" и поддерживает массивы и вложенные структуры.
Часто используется для передачи данных между клиентом и сервером в RESTful API.
Apache Maven:

*Maven* - инструмент для автоматизации сборки проектов, управления зависимостями и генерации документации.
Основные понятия Maven: проект, артефакт, зависимость, цель, плагин.
Файл "pom.xml" содержит настройки проекта, зависимости и инструкции для сборки.
Пример использования:

Мы создали простое RESTful API с использованием Java HTTP Server API.
Пример демонстрирует обработку GET, POST и DELETE запросов к ресурсу "/users".
Для работы с JSON мы использовали библиотеку Jackson для сериализации и десериализации данных.

**Задание Java:**

Задачи:
1. Разработать простой RESTful API для сущности "Книга".
2. Провести тестирование созданного API с помощью инструментов вроде Postman или брузера , как делали на семмнаре

Подробная инструкция:
1. Разработка RESTful API для сущности "Книга"
a. Определение модели "Книга":
- Определите атрибуты для книги: например, ID, название, автор, год издания и т.д.

b. Создание API:
- Используя ваше предпочтительное программное обеспечение или фреймворк (например, Express для Node.js, Flask для Python и т.д.), создайте базовые CRUD операции:
- POST /books - добавить новую книгу.
- GET /books - получить список всех книг.
- GET /books/{id} - получить информацию о конкретной книге по ID.
- PUT /books/{id} - обновить информацию о книге.
- DELETE /books/{id} - удалить книгу.

**Задания на Python:**

Задачи:
1. Разработать простой RESTful API для сущности "Книга" на Python.
2. Провести базовое тестирование созданного API, используя инструменты Python.

Подробная инструкция:
1. Разработка RESTful API для сущности "Книга" на Python
a. Определение модели "Книга":
- Определите атрибуты для книги: например, ID, название, автор, год издания и т.д.

b. Создание API с использованием Flask:
- Установите Flask (если он еще не установлен): pip install Flask.
- Создайте новый файл Python, например app.py.
- Импортируйте необходимые библиотеки и определите экземпляр приложения Flask.
- Определите маршруты и обработчики для базовых CRUD операций:
- POST /books - добавить новую книгу.
- GET /books - получить список всех книг.
- GET /books/<int:id> - получить информацию о конкретной книге по ID.
- PUT /books/<int:id> - обновить информацию о книге.
- DELETE /books/<int:id> - удалить книгу.

Подсказка: Для сохранения данных во временной базе, вы можете использовать структуры данных Python, например, список словарей.

2. Тестирование API с использованием инструментов Python - По желанию
a. Подготовка к тестированию:

Запустите ваше приложение Flask: python app.py.
Удостоверьтесь, что ваш сервер работает и слушает соответствующий порт (обычно 5000).
b. Базовое тестирование CRUD операций с использованием requests:
- Установите библиотеку requests, если она ещё не установлена: pip install requests.
- Создайте новый файл Python для тестирования, например, test_app.py.
- Импортируйте requests и напишите функции тестирования для каждой CRUD операции, отправляя запросы к вашему API и проверяя ответы.

Подсказка: Проверяйте статусы ответов, а также содержание ответов (например, при добавлении новой книги проверьте, что она действительно добавлена в список).

## Урок 10. Структура приложения с пользовательским интерфейсом и базой данных (паттерн Repository) ##

Вы можете реализовать эти патерны, в рамках своего проекта, к которому Вы делали диограммы и таблицы. Или реализовать отдельно от них.

**Домашнее задание:** Реализация паттернов Агрегатор, Репозиторий и Кеширования

Цель: Освоить принципы работы и применение трёх ключевых паттернов проектирования: Агрегатор, Репозиторий и Кеширование.

Часть 1: Паттерн Агрегатор
Реализуйте классы Order, OrderItem и Product.
Order должен содержать список OrderItem, каждый из которых содержит Product и количество этого продукта.
У каждого заказа должен быть метод для расчета общей стоимости.

Часть 2: Паттерн Репозиторий
Создайте интерфейс OrderRepository, который определяет методы для работы с заказами (сохранение, загрузка по ID, загрузка всех заказов и т. д.).
Реализуйте класс OrderRepositoryImpl, который реализует данный интерфейс, используя любую базу данных на ваш выбор (может быть встроенной, например, SQLite).
В репозитории обеспечьте сохранение и загрузку заказов, а также всех связанных с ними объектов (OrderItem, Product).

Часть 3: Паттерн Кеширования
Исследуйте и выберите одну из библиотек для кеширования в Java (например, EhCache, Caffeine или Guava Cache).
Реализуйте кеширование в вашем репозитории таким образом, чтобы часто запрашиваемые заказы загружались из кэша, а не из базы данных.
Обеспечьте инвалидацию кэша (обновление данных в кэше), если информация в базе данных была изменена.
Дополнительное задание:
Реализуйте пользовательский интерфейс (может быть консольным или графическим), чтобы демонстрировать создание, редактирование, загрузку и удаление заказов.
Добавьте возможность фильтрации и сортировки заказов при их загрузке из базы данных.

**Советы:**

Соблюдайте принципы SOLID при проектировании и реализации вашего приложения.
Обрабатывайте все возможные исключения, особенно при работе с базой данных.
Подумайте над оптимальной стратегией кеширования в зависимости от предполагаемого объема данных и частоты запросов.

## Урок 11. Сервис-ориентированные архитектуры ##

Расширяем наш проект
Была одна главная страница- делаем наброски для друг страниц(Заказ, доставка, и т д в зависимости от темы . Пример - https://stealth-force-e00.notion.site/f38d6a54d65542fd97f8fc39aba36758?pvs=4). Вы это делаете для дизайнера, можно сделать и в пейнт, не надо тратить на это много время . https://www.figma.com/
Расширяем диограммы.
Пример на основе приложения для робота-пылесоса: https://geekbrainspro.notion.site/2-11-1b0361e053584d5db3f09064ef90cf2d

1. UML-диаграмма пакетов:

Пакеты и подсистемы: Показывает структуру пакетов и их взаимосвязи. Пакеты могут содержать классы, интерфейсы, диаграммы и другие элементы.
Отношения между пакетами: Диаграмма может показать, как пакеты связаны друг с другом, например, зависимости или ассоциации.

2. UML-диаграмма системы обновления приложения:

Компоненты и связи: Показывает компоненты, связанные с обновлением приложения, такие как "Клиентское приложение", "Сервер обновлений", "База данных версий".
Поток данных: Может включать поток данных от клиентского приложения к серверу обновлений и обратно.

3. UML-диаграмма домена (Domain Diagram):

Сущности и связи: Диаграмма домена обычно представляет ключевые сущности в системе и связи между ними. Это может быть базовая структура данных, которая влияет на всю систему.
Атрибуты: Диаграмма может также включать атрибуты, которые описывают каждую сущность.
Системы и компоненты: Если система состоит из различных подсистем или компонентов, они также могут быть показаны

4. UML-диаграмма системы обновления приложения:

Компоненты и связи: Показывает компоненты, связанные с обновлением приложения, такие как "Клиентское приложение", "Сервер обновлений", "База данных версий".
Поток данных: Может включать поток данных от клиентского приложения к серверу обновлений и обратно.

По желанию, но крайне рекомендуется добавить к своему проекту.
Спроектировать слой  API Gateway (mobile, web), сформировать REST запросы: GET, POST, PUT, DELETE (https://swagger.io).
Предположим, у вас есть простой API для управления списком пользователей. Вам нужно описать запрос типа GET, который вернет список всех пользователей.

- Откройте Swagger: Перейдите на сайт https://swagger.io и, возможно, создайте новую спецификацию или проект, чтобы начать описание вашего API.
- Описание запроса GET:
  + Определите функциональность API Gateway
  + Определите, какие функции будет выполнять ваш API Gateway. Например, это может быть маршрутизация запросов от мобильных устройств и веб-клиентов к соответствующим микросервисам.
- Выберите инструмент Swagger
  + Откройте инструмент Swagger (https://swagger.io) или его альтернативы, которые позволяют создавать и документировать API.
- Создайте новую спецификацию 
  + Если используете Swagger, создайте новую спецификацию (или проект) для вашего API Gateway.
- Определите эндпоинты
  + Определите список эндпоинтов (URL-путей), которые будут доступны через ваш API Gateway. Например, /mobile и /web.
- Сформируйте запросы:
  + Для каждого эндпоинта, определите HTTP-методы, которые он поддерживает (GET, POST, PUT, DELETE).
- Опишите запросы:
  + Для каждого метода опишите, какие параметры (если есть) должны быть переданы в запросе, а также форматы данных запроса и ответа.
- Пример запроса:
  + Предоставьте пример запроса для каждого метода, чтобы пользователи могли понять, как правильно формировать запросы.
- Форматы данных:
  + Укажите, какой формат данных (обычно JSON) используется для передачи данных между клиентами и API Gateway.
- Генерируйте документацию:
  + Используйте возможности инструмента Swagger для автоматической генерации документации на основе вашей спецификации. Документация должна быть понятной и информативной.
- Тестирование:
  + Используйте инструмент Swagger или другие инструменты для тестирования запросов на вашем API Gateway. Убедитесь, что запросы выполняются корректно.
- Документация и доступность:
  + Предоставьте ссылку на документацию вашего API Gateway. Удостоверьтесь, что другие разработчики и клиенты смогут получить доступ к этой документации.


Помните, что проектирование API Gateway - это описание, как клиенты (мобильные приложения, веб-приложения и т.д.) будут взаимодействовать с вашей системой через единый входной точки. Swagger поможет вам создать четкую документацию, которая упростит интеграцию с вашим API Gateway.

Пример выполнения: https://stealth-force-e00.notion.site/289383d7b8b3424f911c04b25d722c80?pvs=4

Задача Swagger - упростить процесс описания и документирования вашего API, а также предоставить средства для тестирования API непосредственно из документации.

## Урок 12. Принципы тестирования приложений ##

Продолжаем свой проект. Заполняем документацию для тестов по примеру.

https://geekbrainspro.notion.site/10-12-824e24672d0242f8b05bb34c842d7aca
